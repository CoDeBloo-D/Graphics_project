# 作业3
171860660 叶新宇


## Ex54
```java
class FIFOConsensus<T> {
	FIFO queue;
	T[] proposed;
	T decide(T value) {
		proposed[ThreadID.get()] = value;
		queue.enq(ThreadID.get());
		return proposed[queue.peek()];
	}
}
```
构造出如上的协议，使用了添加peek()方法的FIFO队列。

该协议无等待，因为FIFO是无等待的，且decide()方法不包含循环。如果每个线程都返回它自己的输入，则peek()必须返回不同值。但是peek()方法并不删除队首元素，因此这违反了FIFO队列的定义。为确保有效性，每个线程在任何值出队之前都会将其值写入proposed数组中。
如上的协议是无等待，一致，有效的，并且可用于任何数量的线程，因此，它是具有**无限**一致数的协议。

也就是说，这样扩展后的FIFO队列具有**无限**的一致数。


## Ex68
只用原子寄存器实现的scan实现的peek()方法的一致数为1。只要deq()方法被调用，peek()方法的返回值就会发生变化，不满足一致性。

如果不使用deq()方法，因为enq()方法不是一个原子操作，items[slot] = x是一个原子寄存器的操作，一致数只有1（虽然getAndIncrement()方法的一致数是2）。故不使用deq()方法实现的协议一致数也是1。


## Ex69
```Java
import java.util.concurrent.atomic.*;
public class NewObject {
	private AtomicInteger v;
	public NewObject(int value) {
		this.v = new AtomicInteger(value);
	}
	public int newCompareAndSet(int expect, int update) {
		v.compareAndSet(expect, update);
		do {
			expect = v.get();
		}while(!v.compareAndSet(expect, expect));
		return expect;
	}
}
```


## Ex85
因为线程自己的结点不仅被自己使用，还被后续结点和tail结点引用。

设有A、B两个Thread。A是B的前驱节点。

B.lock() --> B.pred = A --> B.pred.locked = true --> A.unlock() --> A.locked = false --> A.lock() --> A.locked = true 
--> A.pred = B --> A.pred.locked() = true --> B.pred.locked = true --> A.pred.locked = true

产生了死锁。

被tail引用：

tail = A --> A.lock() --> A.unlock() --> A.lock() --> A.locked = true --> A.pred = tail.getAndSet(A) --> A.pred = A

产生了死锁。


## Ex91
任意testAndSet()自旋锁：
```Java
boolean isLocked() {
	return state.get();
}
```
CLH队列锁：
```Java
boolean isLocked() {
	return tail.get().locked;
}
```
MCS队列锁:
```Java
boolean isLocked() {
	QNode node = queue.get();
	if(node == null)
		return false;
	else
		return node.locked;
}
```
